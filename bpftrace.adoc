= bpftrace(8)
:doctype: manpage
:toc: true

////
Style guide:
- one sentence per line
////

== Name

bpftrace - a high-level tracing language

== Synopsis

*bpftrace* [_OPTIONS_] _FILENAME_ +
*bpftrace* [_OPTIONS_] -e 'program code'

== Description

bpftrace is a high-level tracing language and runtime for Linux based on BPF.
It supports static and dynamic tracing for both the kernel and user-space.

== Examples

List all probes with "sleep" in their name::
-----
  bpftrace -l '*sleep*'
-----

Trace processes calling sleep::
-----
  bpftrace -e 'kprobe:do_nanosleep { printf("%d sleeping\n", pid); }'
-----

Trace processes calling sleep while spawning `sleep 5` as a child process::
-----
  bpftrace -e 'kprobe:do_nanosleep { printf("%d sleeping\n", pid); }' -c 'sleep 5'
-----

== Options

=== *Output format*

*-B* _MODE_::
  Set the buffer mode for stdout. Valid values are::

    *none* No buffering. Each I/O is written as soon as possible +
    *line* Data is written on the first newline or when the buffer is full.
    This is the default mode. +
    *full* Data is written once the buffer is full.

*-f* _FORMAT_::
  Set the output format. Valid values are::

    *json* +
    *text*

*-o* _FILENAME_::
  Write bpftrace tracing output to _FILENAME_ instead of stdout.
  This doesn't include child process (*-c* option) output.
  Errors are still written to stderr.

*--no-warnings*::
  Suppress all warning messages created by bpftrace.

=== Tracing

*-e* _PROGRAM_::
  Execute _PROGRAM_ instead of reading the program from a file

*-I* _DIR_::
  Add the directory _DIR_ to the search path for C headers.
  This option can be used multiple times.

*--include* _FILENAME_::
  Add _FILENAME_ as an include for the pre-processor.
  This is equal to adding '#include _FILENAME_' to the start bpftrace program.
  This option can be used multiple times.

*-l* [_SEARCH_]::
  List all probes that match the _SEARCH_ pattern.
  If the pattern is omitted all probes will be listed.
  This pattern supports wildcards in the same way that probes do.
  E.g. '-l kprobe:*file*' to list all 'kprobes' with 'file' in the
  name.

*--unsafe*::
  Some calls, like 'system', are marked as unsafe as they can have dangerous side effects ('system("rm -rf")') and are disabled by default.
  This flag allows their use.

*-k*::
  Errors from bpf-helpers(7) are silently ignored by default which can lead to strange results.
  This flag enables the detection of errors (except for errors from 'probe_read_*').
  When errors occurs bpftrace will log an error containing the source location and the error code:
-----
stdin:48-57: WARNING: Failed to probe_read_user_str: Bad address (-14)
u:lib.so:"fn(char const*)" { printf("arg0:%s\n", str(arg0));}
                                                 ~~~~~~~~~
-----

*-kk*::
  Similar to '-k' but also includes the errors from 'probe_read_*' helpers.


=== Process management

*-p* _PID_::
  'Attach' to the process with _PID_ as ID. If the process terminates bpftrace terminates as well.
  When using USDT probes they will be attached to only this process.

*-c* _COMMAND_::
  Run '_COMMAND_' as a child process.
  When the child terminates bpftrace stops as well, as if 'exit()' has been called.
  If bpftrace terminates before the child process does the child process will be terminated with a SIGTERM.
  If used, 'USDT' probes these will only be attached to the child process.
  To avoid a race condition when using 'USDTs' the child is stopped after 'execve' using 'ptrace(2)' and continued when all 'USDT' probes are attached. +
  The child PID is available to programs as the 'cpid' builtin. +
  The child process runs with the same privileges as bpftrace itself (usually root).

*--usdt-file-activation*::
  activate usdt semaphores based on file path

=== *Miscellaneous*

*--info*::
  Print detailed information about features supported by the kernel and the bpftrace build.

*-h, --help*::
  Print the help summary

*-V, --version*::
  Print bpftrace version information

*-v*::
  verbose messages

*-d*::
  debug mode

*-dd*::
  verbose debug mode

== Environment Variables

Some behaviour can only be controlled through environment variables.
This section lists all those variables.

=== *BPFTRACE_STRLEN*

Default: 64

Number of bytes allocated on the BPF stack for the string returned by str().

Make this larger if you wish to read bigger strings with str().

Beware that the BPF stack is small (512 bytes), and that you pay the toll again inside printf() (whilst
it composes a perf event output buffer).
So in practice you can only grow this to about 200 bytes.

Support for even larger strings is [being discussed](https://github.com/iovisor/bpftrace/issues/305).

=== *BPFTRACE_NO_CPP_DEMANGLE*

Default: 0

C++ symbol demangling in userspace stack traces is enabled by default.

This feature can be turned off by setting the value of this environment variable to `1`.

=== *BPFTRACE_MAP_KEYS_MAX*

Default: 4096

This is the maximum number of keys that can be stored in a map.
Increasing the value will consume more memory and increase startup times.
There are some cases where you will want to: for example, sampling stack traces, recording timestamps for each page, etc.

=== *BPFTRACE_MAX_PROBES*

Default: 512

This is the maximum number of probes that bpftrace can attach to.
Increasing the value will consume more memory, increase startup times and can incur high performance overhead or even freeze or crash the system.

=== *BPFTRACE_CACHE_USER_SYMBOLS*

Default: 0 if ASLR is enabled on system and `-c` option is not given; otherwise 1

By default, bpftrace caches the results of symbols resolutions only when ASLR (Address Space Layout Randomization) is disabled.
This is because the symbol addresses change with each execution with ASLR.
However, disabling caching may incur some performance.
Set this env variable to 1 to force bpftrace to cache.
This is fine if only trace one program execution.

=== *BPFTRACE_VMLINUX*

Default: None

This specifies the vmlinux path used for kernel symbol resolution when attaching kprobe to offset.
If this value is not given, bpftrace searches vmlinux from pre defined locations.
See src/attached_probe.cpp:find_vmlinux() for details.

=== *BPFTRACE_BTF*

Default: None

The path to a BTF file.
By default, bpftrace searches several locations to find a BTF file.
See src/btf.cpp for the details.

=== *BPFTRACE_PERF_RB_PAGES*

Default: 64

Number of pages to allocate per CPU for perf ring buffer.
The value must be a power of 2.

If you're getting a lot of dropped events bpftrace may not be processing events in the ring buffer fast enough.
It may be useful to bump the value higher so more events can be queued up.
The tradeoff is that bpftrace will use more memory.

== Supported architectures

x86, arm64 and s390x

//TODO: is this true?

== bpftrace Language

=== Overview

The `bpftrace` (`bt`) language is inspired by the D language used by `dtrace` and uses the same program structure.
Each script consists of an preamble and one or more action blocks.

----
preamble

actionblock1
actionblock2
----

Preprocessor and type definitions take place in the preamble:

----
#include <linux/socket.h>
#define RED "\033[31m"

struct S {
  int x;
}
----


Each action block consists of three parts:

----
probe[,probe]
/predicate/ {
  action
}
----

Probes::
  A probe specifies the event and event type to attach too.

Predicate::
  The predicate is optional condition that must be met for the action to be executed.

Action::
  Actions are the programs that run when an event fires (and the predicate is met).
An action is a semicolon (`;`) separated list of statements and always enclosed by brackets `{}`

A basic script that traces the `open(2)` and `openat(2)` system calls can be written as follows:

----
BEGIN
{
	printf("Tracing open syscalls... Hit Ctrl-C to end.\n");
}

tracepoint:syscalls:sys_enter_open,
tracepoint:syscalls:sys_enter_openat
{
	printf("%-6d %-16s %s\n", pid, comm, str(args->filename));
}
----

This script has two action blocks and a total of 3 probes.
The first action block uses the special `BEGIN` probe, which fires once during `bpftrace` startup.
This probe is used to print a header that indicates that the tracing has started.

The second action block uses two probes, one for `open` and one for `openat`, and defines an action that prints the file being `open`ed as well as the `pid` and `comm` of the process that execute the syscall.

=== Identifiers

Identifiers must match the following regular expression: `[_a-zA-Z][_a-zA-Z0-9]*`

=== Comments

Both single line and multi line comments are supported.

----
// A single line comment
i:s:1 { // can also be used to comment inline
/*
 a multi line comment

*/
  print(/* inline comment block */ 1);
}
----

=== Data Types

The following fundamental integer types are provided by the language.

[cols="~,~"]
|===
|*Type*
|*Description*

|uint8
|Unsigned 8 bit integer

|int8
|Signed 8 bit integer

|uint16
|Unsigned 16 bit integer

|int16
|Signed 16 bit integer

|uint32
|Unsigned 32 bit integer

|int32
|Signed 32 bit integer

|uint64
|Unsigned 64 bit integer

|int64
|Signed 64 bit integer
|===

==== Floating-point

Floating-point numbers are not supported by BPF and therefor not by bpftrace.

=== Constants

Integers constants can be defined in the following formats:

- decimal (base 10)
- octal (base 8)
- hexadecimal (base 16)
- scientific (base 10)

Octal constants have to be prefixed with a `0`, e.g. `0123`.
Hexadecimal constants start with either `0x` or `0X`, e.g. `0x10`.
Scientific are written in the `<m>e<n>` format which is a shorthand for `m*10^n`, e.g. `$i = 2e3;`.

Character constants can be defined by enclosing the character in single quotes, e.g. `$c = 'c';`.

String constants cab be defined by enclosing the character string in double quotes, e.g. `$str = "Hello world";`.

Characters and strings support the following escape sequences:

[cols="~,~"]
|===
| \n
|Newline

| \t
|Tab

| \0nn
|Octal value nn

| \xnn
|Hexadecimal value nn

|===

=== Type conversion

Integer and pointer types can be converted using explicit type conversion with an expression like:

----
$y = (uint32) $z;
$py = (int16 *) $pz;
----

Integer casts to a higher rank are sign extended.
Conversion to a lower rank is done by zeroing leading bits.

=== Operators and Expressions

==== Arithmetic Operators

The following operators are available for integer arithmetic:

[cols="~,~"]
|===
| +
|integer addition

| -
|integer subtraction

| *
|integer multiplication

| /
|integer division

| %
|integer modulo

|===

// TODO: Words about integer conversion when types mismatch

==== Logical Operators

[cols="~,~"]
|===
| &&
| Logical AND

| \|\|
| Logical OR

| !
| Logical NOT

|===

==== Bitwise Operators

[cols="~,~"]
|===
| &
| AND

| \|
| OR

| ^
| XOR

| <<
| Left shift the left-hand operand by the number of bits specified by the right-hand expression value

| >>
| Right shift the left-hand operand by the number of bits specified by the right-hand expression value
|===


==== Relational Operators

The following relational operators are defined for integers and pointers.

[cols="~,~"]
|===
| <
| left-hand expression is less than right-hand

| <
| left-hand expression is less than or equal to right-hand

| >
| left-hand expression is bigger than right-hand

| >=
| left-hand expression is bigger or equal to than right-hand

| ==
| left-hand expression equal to right-hand

| !=
| left-hand expression not equal to right-hand

|===

The following relation operators are available for comparing strings.

[cols="~,~"]
|===

| ==
| left-hand string equal to right-hand

| !=
| left-hand string not equal to right-hand

|===


==== Assignment Operators

The following assignment operators can be used on both `map` and `scratch` variables:

[cols="~,~"]
|===

| =
| Assignment, assign the right-hand expression to the left-hand variable

| <<=
| Update the variable with it's value left shifted by the number of bits specified by the right-hand expression value

| >>=
| Update the variable with it's value right shifted by the number of bits specified by the right-hand expression value

| +=
| Increment the variable by the right-hand expression value

| -=
| Decrement the variable by the right-hand expression value

| *=
| Multiple the variable by the right-hand expression value

| /=
| Divide the variable by the right-hand expression value

| %=
| Modulo the variable by the right-hand expression value

| &=
| Bitwise AND the variable by the right-hand expression value

| \|=
| Bitwise OR the variable by the right-hand expression value

| ^=
| Bitwise XOR the variable by the right-hand expression value

|===


All these operators are syntactic sugar for combining assignment with the specified operator.
`@ -= 5` is equal to `@ = @ - 5`.


==== Increment and Decrement Operators

The increment (`\++`) and decrement (`--`) operators can be used on integer and pointer variables to increment their value by one.
They can only be used on variables and can either be applied as prefix or suffix.
The difference is that the expression `x++` returns the original value of `x`, before it got incremented while `++x` returns the value of `x` post increment.
E.g.

----
$x = 10;
$y = $x--; // y = 10; x = 9
$a = 10;
$b = --$a; // a = 9; b = 9
----


Note that maps will be implictly declared and initialized to 0 if not already declared or defined.
Scratch variables must be initialized before using these operators.

=== Variables and Maps

bpftrace knows two types of variables, `scratch` and `map`.

'scratch' variables are kept on the BPF stack and only exists during the execution of the action block and cannot be accessed outside of the program.
Scratch variable names always start with a `$`, e.g. `$myvar`.

'map' variables use BPF 'maps'.
These exist for the lifetime of `bpftrace` itself and can be accessed from all action blocks and user-space.
Map names always start with a `@`, e.g. `@mymap`.

All valid identifiers can be used as `name`.

The data type of a variable is automatically determined during first assignment and cannot be changed afterwards.

==== Associative Arrays

Associative arrays are a collection of elements indexed by a key, similar to the hash tables found in languages like C++ (`std::map`) and Python (`dict`).
They're a variant of 'map' variables.

----
@name[key] = expression
@name[key1,key2] = expression
----

Just like with any variable the type is determined on first use and cannot be modified afterwards.
This applies to both the key(s) and the value type.

The following snippet creates a map with key signature `[int64, string[16]]` and a value type of `int64`:

----
@[pid, comm]++
----

=== Variable scoping

// TODO

=== Pointers

Pointers in bpftrace are similar to those found in `C`.

=== Tuples

bpftrace has support for immutable N-tuples (`n > 1`).
A tuple is a sequence type (like an array) where, unlike an array, every element can have a different type.

Tuples are a comma separated list of expressions, enclosed in brackets, `(1,2)`
Individual fields can be accessed with the `.` operator.
Tuples are zero indexed like arrays are.

----
i:s:1 {
  $a = (1,2);
  $b = (3,4, $a);
  print($a);
  print($b);
  print($b.0);
}
----

Prints:
----
(1, 2)
(3, 4, (1, 2))
3
----

==== Arrays

bpftrace supports accessing one-dimensional arrays like those found in `C`.

Constructing arrays from scratch, like `int a[] = {1,2,3}` in `C`, is not supported.
They can only be read into a variable from a pointer.

The `[]` operator is used to access elements.

----
struct MyStruct {
  int y[4];
}

kprobe:dummy {
  $s = (struct MyStruct *) arg0;
  print($s->y[0]);
}
----

=== Structs

`C` like structs are supported by bpftrace.
Fields are accessed with the `.` operator.
Fields of a pointer to a struct can be accessed with the `->` operator.

Custom struct can be defined in the preamble

Constructing structs from scratch, like `struct X var = {.f1 = 1}` in `C`, is not supported.
They can only be read into a variable from a pointer.

----
struct MyStruct {
  int a;
}

kprobe:dummy {
  $ptr = (struct MyStruct *) arg0;
  $st = *$ptr;
  print($st.a);
  print($ptr->a);
}
----

=== Conditionals

Conditional expressions are supported in the form of if/else statements and the ternary operator.

The ternary operator consists of three operands: a condition followed by a `?`, the expression to execute when the condition is true followed by a `:` and the expression to execute if the condition is false.

----
condition ? ifTrue : ifFalse
----

Both the `ifTrue` and `ifFalse` expressions must be of the same type, mixing types is not allowed.

The ternary operator can be used as part of an assignment.

----
$a == 1 ? print("true") : print("false");
$b = $a > 0 ? $a : -1;
----

If/else statements, like the one in `C`, are supported.

----
if (condition) {
  ifblock
} else if (condition) {
  if2block
} else {
  elseblock
}
----

=== Loops

Since kernel 5.3 BPF supports loops as long as the verifier can proof they're bounded and fit within the instruction limit.

In bpftrace loops are available through the `while` statement.

----
while (condition) {
  block;
}
----

Within a while-loop the following control flow statements can be used:

[cols="~,~"]
|===

| continue
| skip processing of the rest of the block and jump back to the evaluation of the conditional

| break
| Terminate the loop

|===

----
i:s:1 {
  $i = 0;
  while ($i <= 100) {
    printf("%d ", $i);
    if ($i > 5) {
      break;
    }
    $i++
  }
  printf("\n");
}
----

Loop unrolling is also supported with the `unroll` statement.

----
unroll(n) {
  block;
}
----

The compiler will evaluate the block `n` times and generate the BPF code for the block `n` times.
As this happens at compile time `n` must be a constant greater than 0 (`n > 0`).

The following two probes compile into the same code:

----
i:s:1 {
  unroll(3) {
    print("Unrolled")
  }
}

i:s:1 {
  print("Unrolled")
  print("Unrolled")
  print("Unrolled")
}
----

----
i:s:1 {
  $i = 1;
  unroll(3) {
    printf("i: %d\n", $i);
    $i = $i + 1;
  }
}
----

=== Builtins

Builtins are special variables built into the language.
Unlike the scratch and map variable they don't need a `$` or `@` as prefix.

[%header,cols="~,~,~,~,~"]
|===
| Variable
| Type
| Kernel
| BPF Helper
| Description

| `$1`, `$2`, `...$n`
| int64
| n/a
| n/a
| The nth positional parameter passed to the bpftrace program.
If less than n parameters are passed this evaluates to `0`.
For string arguments use the `str()` call to retrieve the value.

| `$#`
| int64
| n/a
| n/a
| Total amount of positional parameters passed.

| `arg0`, `arg1`, `...argn`
| int64
| n/a
| n/a
| nth argument passed to the function being traced. These are extracted from the CPU registers. The amount of args passed in registers depends on the CPU architecture. (kprobes, uprobes, usdt).

| cgroup
| uint64
| 4.18
| get_current_cgroup_id
| ID of the cgroup the current task is in. Only works with cgroupv2.

| comm
| string[16]
| 4.2
| get_current_com
| `comm` of the current task. Equal to the value in `/proc/<pid>/comm`

| cpid
| uint32
| n/a
| n/a
| PID of the child process

| cpu
| uint32
| 4.1
| raw_smp_processor_id
| ID of the processor executing the BPF program

| curtask
| uint64
| 4.8
| get_current_task
| Pointer to `struct task_struct` of the current task

| elapsed
| uint64
| (see nsec)
| ktime_get_ns / ktime_get_boot_ns
| Nanoseconds elapsed since bpftrace initialization, based on `nsecs`

| func
| string
| n/a
| n/a
| Name of the current function being trace (kprobes,uprobes)

| gid
| uint64
| 4.2
| get_current_uid_gid
| GID of current task

| kstack
| kstack
|
| get_stackid
| Kernel stack trace

| nsecs
| uint64
| 4.1 / 5.7
| ktime_get_ns / ktime_get_boot_ns
| nanoseconds since kernel boot. On kernels that support `ktime_get_boot_ns` this includes the time spend suspended, on older kernels it does not.

| pid
| uint64
| 4.2
| get_current_pid_tgid
| Process ID (or thread group ID) of the current task.

| probe
| string
| n/na
| n/a
| Name of the current probe

| rand
| uint32
| 4.1
| get_prandom_u32
| Random number

| retval
| int64
| n/a
| n/a
| Value returned by the function being traced (kretprobe, uretprobe, kretfunc)

| `arg0`, `arg1`, `...argn`
| int64
| n/a
| n/a
| nth stack value of the function being traced. (kprobes, uprobes).

| tid
| uint64
| 4.2
| get_current_pid_tgid
| Thread ID of the current task.

| uid
| uint64
| 4.2
| get_current_uid_gid
| UID of current task

| ustack
| ustack
| 4.6
| get_stackid
| Userspace stack trace

|===

=== Map Functions

Map functions are built-in functions who's return value can only be assigned to maps.
The data type associated with these functions are only for internal use and are not compatible with the (integer) operators.

Functions that are marked *async* are asynchronous which can lead to unexpected behaviour, see the 'sync and async' section for more information. // TODO: LINK

==== avg(int64 n)

Calculate the running average of `n` between consecutive calls.

----
i:s:1 {
  @x++;
  @y = avg(@x);
  print(@x);
  print(@y);
}
----

Internally this keeps two values in the map: value count and running total.
The average is computed in user-space when printing by dividing the total by the count.

==== clear(map m)

*async*

Clear all keys/values from map `m`.

----
i:ms:100 {
  @[rand % 10] = count();
}

i:s:10 {
  print(@);
  clear(@);
}
----

==== count()

Count how often this function is called.

Using `@=count()` is conceptually similar to `@++`.
The difference is that the `count()` function uses a map type optimized for this (PER_CPU), increasing performance.
Due to this the map cannot be accessed as a regular integer.

----
i:ms:100 {
  @ = count();
}

i:s:10 {
  print(@);
  clear(@);
}
----

==== delete(mapkey k)

Delete a single key from a map.
For a single value map this deletes the only element.
For an associative-array the key to delete has to be specified.

```
k:dummy {
  @scalar = 1;
  @associative[1,2] = 1;
  delete(@scalar);
  delete(@associative[1,2]);

  delete(@associative); // error
}
```

==== hist(int64 n)

Create a log2 histogram of `n`.

----
kretprobe:vfs_read {
  @bytes = hist(retval);
}
----

Results in:

----
@:
[1M, 2M)               3 |                                                    |
[2M, 4M)               2 |                                                    |
[4M, 8M)               2 |                                                    |
[8M, 16M)              6 |                                                    |
[16M, 32M)            16 |                                                    |
[32M, 64M)            27 |                                                    |
[64M, 128M)           48 |@                                                   |
[128M, 256M)          98 |@@@                                                 |
[256M, 512M)         191 |@@@@@@                                              |
[512M, 1G)           394 |@@@@@@@@@@@@@                                       |
[1G, 2G)             820 |@@@@@@@@@@@@@@@@@@@@@@@@@@@                         |
----

==== lhist(int64 n, int64 min, int64 max, int64 step)

Create a linear histogram of `n`.
`lhist` creates `M` (`(max - min) / step`) buckets in the range `[min,max)` where each bucket is `step` in size.
Values in the range `(-inf, min)` and `(max, inf)` get their get their own bucket too, bringing the total amount of buckets created to `M+2`.

----
i:ms:1 {
  @ = lhist(rand %10, 0, 10, 1);
}

i:s:5 {
  exit();
}
----

Prints:

----
@:
[0, 1)               306 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@         |
[1, 2)               284 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@            |
[2, 3)               294 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@          |
[3, 4)               318 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@       |
[4, 5)               311 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        |
[5, 6)               362 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@|
[6, 7)               336 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@    |
[7, 8)               326 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@      |
[8, 9)               328 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@     |
[9, 10)              318 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@       |
----

==== max(int64 n)

Update the map with `n` if `n` is bigger than the current value held.

==== min(int64 n)

Update the map with `n` if `n` is smaller than the current value held.

==== stats(int64 n)

`stats` combines the `count`, `avg` and `sum` calls into one.

----
kprobe:vfs_read {
  @bytes[comm] = stats(arg2);
}
----

----
@bytes[bash]: count 7, average 1, total 7
@bytes[sleep]: count 5, average 832, total 4160
@bytes[ls]: count 7, average 886, total 6208
@
----

==== sum(int64 n)

Calculate the sum of all `n` passed.

==== zero(map m)

*async*

Set all values for all keys to zero.

=== Functions

Functions that are marked *async* are asynchronous which can lead to unexpected behaviour, see the 'sync and async' section for more information. // TODO: LINK

*compile time* functions are evaluated at compile time, a static value will be compiled into the program.

*unsafe* functions can have dangerous side effects and should be used with care, the `--unsafe` flag is required for use.

==== buf_t buf(void * data, [int64 length])

`buf` reads `length` amount of bytes from address `data`.
The maximum value of `length` is limited to the `BPFTRACE_STRLEN` variable.
For arrays the `length` is optional, it is automatically inferred from the signature.

`buf` is address space aware and will call the correct helper based on the address space associated with `data`.

The `buf_t` object returned by `buf` can safely be printed as a hex encoded string with the `%r` format specifier.

----
i:s:1 {
  printf("%r\n", buf(kaddr("avenrun"), 8));
}
----

----
\x00\x03\x00\x00\x00\x00\x00\x00
\xc2\x02\x00\x00\x00\x00\x00\x00
----

==== void cat(string namefmt, [...args])

*async*

Dump the contents of the named file to stdout.
`cat` supports the same format string and arguments that `printf` does.
If the file cannot be opened or read an error is printed to stderr.

----
t:syscalls:sys_enter_execve {
  cat("/proc/%d/maps", pid);
}
----

----
55f683ebd000-55f683ec1000 r--p 00000000 08:01 1843399                    /usr/bin/ls
55f683ec1000-55f683ed6000 r-xp 00004000 08:01 1843399                    /usr/bin/ls
55f683ed6000-55f683edf000 r--p 00019000 08:01 1843399                    /usr/bin/ls
55f683edf000-55f683ee2000 rw-p 00021000 08:01 1843399                    /usr/bin/ls
55f683ee2000-55f683ee3000 rw-p 00000000 00:00 0
----

==== uint64 cgroupid(const string path)

*compile time*

`cgroupid` retrieves the cgroupv2 ID  of the cgroup available at `path`.

----
BEGIN {
  print(cgroupid("/sys/fs/cgroup/system.slice"));
}
----


==== void exit()

*async*

Terminate bpftrace, as if a `SIGTERM` was received.
The `END` probe will still trigger and maps will be printed.

==== void join(char *arr[], [char * sep = ' '])

*async*

`join` joins all the string array `arr` with `sep` as separator into one string.
This string will be printed to stdout directly, it cannot be used as string value.

The concatenation of the array members is done in BPF and the printing happens in userspace.

----
tracepoint:syscalls:sys_enter_execve {
  join(args->argv);
}
----

==== uint64 kaddr(const string name)

*compile time*

Get the address of the kernel symbol `name`.

The following script:

==== T * kptr(T * ptr)

Marks `ptr` as a kernel address space pointer.
See the address-spaces section for more information on address-spaces.
The pointer type is left unchanged.

==== ksym_t ksym(uint64 addr)

*async*

Print the name of the function that contains address `addr`.
The address to name mapping happens in user-space.

The `ksym_t` type can be printed with the `%s` format specifier.


==== macaddr_t macaddr(char [6] mac)

Create a buffer that holds a macaddress as read from `mac`
This buffer can be printed in the canonical string format using the `%s` format specifier.

----
kprobe:arp_create {
  printf("SRC %s, DST %s\n", macaddr(sarg0), macaddr(sarg1));
}
----

Prints:

----
SRC 18:C0:4D:08:2E:BB, DST 74:83:C2:7F:8C:FF
----

==== inet_t ntop()

.Variants
* `inet_t ntop([int64 af, ] int addr)`
* `inet_t ntop([int64 af, ] char addr[4])`
* `inet_t ntop([int64 af, ] char addr[16])`

`ntop` returns the string representation of an IPv4 or IPv6 address.
`ntop` will infer the address type (IPv4 or IPv6) based on the `addr` type and size.
If an integer or `char[4]` is given, ntop assumes IPv4, if a `char[16]` is given, ntop assumes IPv6.
You can also pass the address type (e.g. AF_INET) explicitly as the first parameter.

==== override(uint64 rc)

*unsafe*

Kernel: 4.16
.Supported probes
* kprobe
Helper: `bpf_override`

When using `override` the probed function will not be executed and instead `rc` will be returned.

----
k:__x64_sys_getuid
/comm == "id"/ {
  override(2<<21);
}
----

----
uid=4194304 gid=0(root) euid=0(root) groups=0(root)
----

This feature only works on kernels compiled with `CONFIG_BPF_KPROBE_OVERRIDE` and only works on functions tagged `ALLOW_ERROR_INJECTION`.

bpftrace does not test whether error injection is allowed for the probed function, instead if will fail to load the program into the kernel:

----
ioctl(PERF_EVENT_IOC_SET_BPF): Invalid argument
Error attaching probe: 'kprobe:vfs_read'
----

==== reg(string name)

.Supported probes
* kprobe
* uprobe

Get the contents of the register identified by `name`.
Valid names depend on the CPU architecture:

[cols="~,~"]
|===
|*Arch*
|*register names*

| x86
| r15, r14, r13, r12, bp, bx, r11, r10, r9, r8, ax, cx, dx, si, di, orig_ax, ip, cs, flags, sp, ss

| aarch64
| r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14, r15, r16, r17, r18, r19, r20, r21, r22, r23, r24, r25, r26, r27, r28, r29, r30, sp, pc, pstate
|===

==== signal(string sig)

*unsafe*

.Variants
* `signal(string sig)`
* `signal(uint32 signum)`

Kernel: 5.3
Helper: `bpf_send_signal`
Probe types: k(ret)probe, u(ret)probe, USDT, profile

Send a signal to the process being traced.
The signal can either be identified by name, e.g. `SIGSTOP` or by ID, e.g. `19` as found in `kill -l`.

----
kprobe:__x64_sys_execve
/comm == "bash"/ {
  signal(5);
}
----
----
$ ls
Trace/breakpoint trap (core dumped)
----

==== sizeof(T x)

*compile time*

.Variants
* `sizeof(TYPE)`
* `sizeof(EXPRESSION)`

Returns size of the argument in bytes.
Similar to C/C++ `sizeof` operator.
Note that the expression does not get evaluated.

==== str(char * data [, uint32 length)

Helper: `probe_read_str, probe_read_{kernel,user}_str`
Probe types: any

`str` reads a NULL terminated (`\0`) string from `data`.
The maximum string length is limited by the `BPFTRACE_STR_LEN` env variable, unless `length` is specified and shorter than the maximum. //TODO: add ref
In case the string is longer than the specified length only `length - 1` bytes are copied and a NULL byte is appended at the end.

When available (starting from kernel 5.5, see the `--info` flag) bpftrace will automatically use the `kernel` or `user` variant of `probe_read_{kernel,user}_str` based on the address space of `data`, see Addres-spaces for more information. //TODO: add ref

==== strtime_t strftime(const string fmt, int64 timestamp_ns)

*async*

Format the nanoseconds since boot timestamp `timestamp_ns` according to the format specified by `fmt`.
The time conversion and formatting happens in user space, therefore  the `timestr_t` value returned can only be used for printing using the `%s` format specifier.

bpftrace uses the `strftime(3)` function for formatting time and supports the same format specifiers.

----
i:s:1 {
  printf("%s\n", strftime("%H:%M:%S", nsecs));
}
----

==== int64 strncmp(char * s1, char * s2, int64 n)

`strncmp` compares up to `n` characters string `s1` and string `s2`.
If they're equal `0` is returned, else a non-zero value is returned.

bpftrace doesn't read past the length of the shortest string.

The use of the `==` and `!=` operators is recommended over calling `strncmp` directly.

==== void system(string namefmt [, ...args])

*unsafe*
*async*

`system` lets bpftrace run the specified command (`fork` and `exec`) until it completes and print it's stdout.
The `command` is ran with the same privileges as bpftrace and it blocks execution of the processing threads which can lead to missed events and delays processing of async events.


----
i:s:1 {
  time("%H:%M:%S: ");
  printf("%d\n", @++);
}
i:s:10 {
  system("/bin/sleep 10");
}
i:s:30 {
  exit();
}
----

Note how the async `time` and `printf` first print every second until the `i:s:10` probe hits, then they print every 10 seconds due to bpftrace blocking on `sleep`.

----
Attaching 3 probes...
08:50:37: 0
08:50:38: 1
08:50:39: 2
08:50:40: 3
08:50:41: 4
08:50:42: 5
08:50:43: 6
08:50:44: 7
08:50:45: 8
08:50:46: 9
08:50:56: 10
08:50:56: 11
08:50:56: 12
08:50:56: 13
08:50:56: 14
08:50:56: 15
08:50:56: 16
08:50:56: 17
08:50:56: 18
08:50:56: 19
----


`system` supports the same format string and arguments that `printf` does.

----
t:syscalls:sys_enter_execve {
  system("/bin/grep %s /proc/%d/status", "vmswap", pid);
}
----

==== void time(const string fmt)

*async*

Format the current wall time according to the format specifier `fmt` and print it to stdout.
Unlike `strftime()` `time()` doesn't send a timestamp from the probe, instead it is the time at which user-space processes the event.

bpftrace uses the `strftime(3)` function for formatting time and supports the same format specifiers.

==== T* uaddr(const string sym)

.Supported probes
* uprobes
* uretprobes
* USDT

**Does not work with ASLR, see issue link:https://github.com/iovisor/bpftrace/issues/75[#75]**

The `uaddr` function returns the address of the specified symbol.
This lookup happens during program compilation and cannot be used dynamically.

The default return type is `u64*`.
If the ELF object size matches a known integer size (1, 2, 4 or 8 bytes) the return type is modified to match the width (`uint8*`, `uint16*`, `uint32*` or `uint64*` resp.).
As ELF does not contain type info the type is always assumed to be unsigned.

----
uprobe:/bin/bash:readline {
  printf("PS1: %s\n", str(*uaddr("ps1_prompt")));
}
----

==== T * uptr(T * ptr)

Marks `ptr` as a user address space pointer.
See the address-spaces section for more information on address-spaces.
The pointer type is left unchanged.

==== usym
==== path
==== unwatch

=== Output formatting

=== print
=== printf
----
print("\033[31mRed\t\033[33mYellow\033[0m\n")
----

=== Probe types

==== BEGIN, END
==== hardware
==== interval
==== kfunc, kretfunc
==== kprobe, kretprobe
==== profile
==== software
==== tracepoint
==== uprobe, uretprobe
==== usdt
==== watchpoint, asynwatchpoint

== Sync and Async

While BPF in the kernel can do a lot there is still work that can only be done from userspace, like the outputting of data.
The way bpftrace handles this is by sending events from the BPF program which user-space will pick up some time in the future (usually in milliseconds).

== Address-spaces

Kernel and user pointers live in different address spaces that, depending on the CPU architecture, might overlap.
Trying to read a pointer that is in the wrong address space results in an error (with the `-kk` flag):

----
stdin:1:9-12: WARNING: Failed to probe_read_user: Bad address (-14)
BEGIN { @=*uptr(kaddr("do_poweroff")) }
        ~~~
----

Bpftrace tries to automatically set the correct address space for a pointer, but might fail in cases where it is unclear.
The address space can be changed with the `kptr()` and `uptr()` functions.
